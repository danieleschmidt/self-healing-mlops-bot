"""Security vulnerability detection for MLOps systems."""

from typing import List, Dict, Any, Optional, Set, Tuple
import logging
import re
import json
import hashlib
from datetime import datetime, timedelta
from collections import defaultdict
import subprocess
import tempfile
import os

from .base import BaseDetector
from ..core.context import Context

logger = logging.getLogger(__name__)


class SecurityVulnerabilityDetector(BaseDetector):
    """Detect security vulnerabilities in dependencies, code, and configuration."""
    
    def __init__(self, config: Dict[str, Any] = None):
        super().__init__(config)
        
        # Vulnerability severity thresholds
        self.critical_score_threshold = self.config.get("critical_score_threshold", 9.0)
        self.high_score_threshold = self.config.get("high_score_threshold", 7.0)
        self.medium_score_threshold = self.config.get("medium_score_threshold", 4.0)
        
        # Dependency scanning configuration
        self.scan_dependencies = self.config.get("scan_dependencies", True)
        self.dependency_databases = self.config.get("dependency_databases", ["osv", "cve", "ghsa"])
        self.max_age_days = self.config.get("max_vulnerability_age_days", 30)
        
        # Code scanning patterns
        self.code_scanning_enabled = self.config.get("code_scanning_enabled", True)
        self.secret_patterns = self._initialize_secret_patterns()
        self.security_patterns = self._initialize_security_patterns()
        
        # Container and infrastructure scanning
        self.container_scanning = self.config.get("container_scanning_enabled", True)
        self.config_scanning = self.config.get("config_scanning_enabled", True)
        
        # Caching and rate limiting
        self.vulnerability_cache = {}
        self.cache_ttl_hours = self.config.get("cache_ttl_hours", 24)
        self.last_scan_times = {}
        self.min_scan_interval_hours = self.config.get("min_scan_interval_hours", 6)
        
        # Alert configuration
        self.alert_on_new_only = self.config.get("alert_on_new_vulnerabilities_only", True)
        self.suppressed_cves = set(self.config.get("suppressed_cves", []))
        
        # Known vulnerability tracking
        self.known_vulnerabilities = set()
    
    def get_supported_events(self) -> List[str]:
        return ["push", "pull_request", "schedule", "workflow_run", "dependency_update", "security_scan"]
    
    async def detect(self, context: Context) -> List[Dict[str, Any]]:
        """Detect security vulnerabilities across multiple vectors."""
        issues = []
        
        try:
            # Dependency vulnerability scanning
            if self.scan_dependencies:
                dep_issues = await self._scan_dependencies(context)
                issues.extend(dep_issues)
            
            # Code vulnerability scanning
            if self.code_scanning_enabled:
                code_issues = await self._scan_code_vulnerabilities(context)
                issues.extend(code_issues)
            
            # Container security scanning
            if self.container_scanning:
                container_issues = await self._scan_container_vulnerabilities(context)
                issues.extend(container_issues)
            
            # Configuration security scanning
            if self.config_scanning:
                config_issues = await self._scan_configuration_security(context)
                issues.extend(config_issues)
            
            # Secret detection in code
            secret_issues = await self._detect_secrets_in_code(context)
            issues.extend(secret_issues)
            
            # Infrastructure security assessment
            infra_issues = await self._assess_infrastructure_security(context)
            issues.extend(infra_issues)
            
            # License compliance checking
            license_issues = await self._check_license_compliance(context)
            issues.extend(license_issues)
            
        except Exception as e:
            logger.exception(f"Error in security vulnerability detection: {e}")
            issues.append(self.create_issue(
                issue_type="security_scan_error",
                severity="medium",
                message=f"Security vulnerability detection failed: {str(e)}",
                data={"error_details": str(e)}
            ))
        
        return issues
    
    async def _scan_dependencies(self, context: Context) -> List[Dict[str, Any]]:
        """Scan dependencies for known vulnerabilities."""
        issues = []
        
        # Check if we should skip scan based on frequency
        scan_key = f"deps_{context.repo_full_name}"
        if not self._should_scan(scan_key):
            logger.info("Skipping dependency scan due to frequency limits")
            return issues
        
        # Get dependency files
        dependency_files = await self._get_dependency_files(context)
        
        for dep_file in dependency_files:
            file_path = dep_file["path"]
            file_type = dep_file["type"]
            dependencies = dep_file["dependencies"]
            
            logger.info(f"Scanning {len(dependencies)} dependencies in {file_path}")
            
            vulnerabilities = await self._check_dependencies_for_vulnerabilities(
                dependencies, file_type, file_path
            )
            
            for vuln in vulnerabilities:
                # Skip suppressed CVEs
                if any(cve in self.suppressed_cves for cve in vuln.get("cve_ids", [])):
                    continue
                
                # Skip if already known and alert_on_new_only is enabled
                vuln_id = vuln.get("id", "")
                if self.alert_on_new_only and vuln_id in self.known_vulnerabilities:
                    continue
                
                severity = self._calculate_vulnerability_severity(vuln)
                
                issues.append(self.create_issue(
                    issue_type="dependency_vulnerability",
                    severity=severity,
                    message=f"Vulnerability in {vuln['package']} {vuln['version']}: {vuln['title']}",
                    data={
                        "package_name": vuln["package"],
                        "package_version": vuln["version"],
                        "vulnerability_id": vuln["id"],
                        "cve_ids": vuln.get("cve_ids", []),
                        "cvss_score": vuln.get("cvss_score", 0),
                        "severity_level": vuln.get("severity", "unknown"),
                        "description": vuln.get("description", ""),
                        "fixed_versions": vuln.get("fixed_versions", []),
                        "file_path": file_path,
                        "file_type": file_type,
                        "published_date": vuln.get("published", ""),
                        "recommendation": self._get_vulnerability_recommendation(vuln)
                    }
                ))
                
                # Track known vulnerabilities
                if vuln_id:
                    self.known_vulnerabilities.add(vuln_id)
        
        # Update scan timestamp
        self.last_scan_times[scan_key] = datetime.utcnow()
        
        return issues
    
    async def _scan_code_vulnerabilities(self, context: Context) -> List[Dict[str, Any]]:
        """Scan code for security vulnerabilities and anti-patterns."""
        issues = []
        
        # Get source code files
        source_files = await self._get_source_files(context)
        
        for file_info in source_files:
            file_path = file_info["path"]
            file_content = file_info["content"]
            
            # Scan for security anti-patterns
            security_issues = self._scan_file_for_security_issues(file_path, file_content)
            
            for issue in security_issues:
                issues.append(self.create_issue(
                    issue_type="code_security_vulnerability",
                    severity=issue["severity"],
                    message=f"Security issue in {file_path}: {issue['title']}",
                    data={
                        "file_path": file_path,
                        "line_number": issue.get("line_number", 0),
                        "pattern_type": issue["pattern_type"],
                        "description": issue["description"],
                        "code_snippet": issue.get("code_snippet", ""),
                        "recommendation": issue["recommendation"],
                        "cwe_id": issue.get("cwe_id", "")
                    }
                ))
        
        return issues
    
    async def _scan_container_vulnerabilities(self, context: Context) -> List[Dict[str, Any]]:
        """Scan container images for security vulnerabilities."""
        issues = []
        
        # Find container definitions
        container_files = await self._get_container_files(context)
        
        for container_file in container_files:
            file_path = container_file["path"]
            base_images = container_file["base_images"]
            
            for base_image in base_images:
                vulnerabilities = await self._scan_container_image(base_image, file_path)
                
                for vuln in vulnerabilities:
                    severity = self._calculate_container_vulnerability_severity(vuln)
                    
                    issues.append(self.create_issue(
                        issue_type="container_vulnerability",
                        severity=severity,
                        message=f"Container vulnerability in {base_image}: {vuln['title']}",
                        data={
                            "container_file": file_path,
                            "base_image": base_image,
                            "vulnerability_id": vuln["id"],
                            "package_name": vuln.get("package", ""),
                            "package_version": vuln.get("version", ""),
                            "cvss_score": vuln.get("cvss_score", 0),
                            "description": vuln.get("description", ""),
                            "layer": vuln.get("layer", ""),
                            "recommendation": self._get_container_vulnerability_recommendation(vuln)
                        }
                    ))
        
        return issues
    
    async def _scan_configuration_security(self, context: Context) -> List[Dict[str, Any]]:
        """Scan configuration files for security misconfigurations."""
        issues = []
        
        # Get configuration files
        config_files = await self._get_configuration_files(context)
        
        for config_file in config_files:
            file_path = config_file["path"]
            file_type = config_file["type"]
            config_content = config_file["content"]
            
            security_issues = self._analyze_config_security(file_path, file_type, config_content)
            
            for issue in security_issues:
                issues.append(self.create_issue(
                    issue_type="configuration_security_issue",
                    severity=issue["severity"],
                    message=f"Security misconfiguration in {file_path}: {issue['title']}",
                    data={
                        "file_path": file_path,
                        "file_type": file_type,
                        "issue_type": issue["issue_type"],
                        "description": issue["description"],
                        "current_value": issue.get("current_value", ""),
                        "recommended_value": issue.get("recommended_value", ""),
                        "recommendation": issue["recommendation"]
                    }
                ))
        
        return issues
    
    async def _detect_secrets_in_code(self, context: Context) -> List[Dict[str, Any]]:
        """Detect hardcoded secrets, API keys, and credentials in code."""
        issues = []
        
        # Get all text files
        text_files = await self._get_text_files(context)
        
        for file_info in text_files:
            file_path = file_info["path"]
            file_content = file_info["content"]
            
            secrets = self._scan_file_for_secrets(file_path, file_content)
            
            for secret in secrets:
                # Calculate severity based on secret type
                severity = self._get_secret_severity(secret["type"])
                
                issues.append(self.create_issue(
                    issue_type="secret_detected",
                    severity=severity,
                    message=f"Potential secret detected in {file_path}: {secret['type']}",
                    data={
                        "file_path": file_path,
                        "line_number": secret.get("line_number", 0),
                        "secret_type": secret["type"],
                        "description": secret["description"],
                        "pattern_matched": secret["pattern_name"],
                        "entropy_score": secret.get("entropy", 0),
                        "confidence": secret.get("confidence", "medium"),
                        "recommendation": "Remove hardcoded secret and use secure secret management"
                    }
                ))
        
        return issues
    
    async def _assess_infrastructure_security(self, context: Context) -> List[Dict[str, Any]]:
        """Assess infrastructure security configuration."""
        issues = []
        
        # Check CI/CD security
        ci_issues = await self._assess_cicd_security(context)
        issues.extend(ci_issues)
        
        # Check repository security settings
        repo_issues = await self._assess_repository_security(context)
        issues.extend(repo_issues)
        
        return issues
    
    async def _check_license_compliance(self, context: Context) -> List[Dict[str, Any]]:
        """Check for license compliance issues."""
        issues = []
        
        # Get dependency licenses
        license_info = await self._get_dependency_licenses(context)
        
        # Check for problematic licenses
        prohibited_licenses = self.config.get("prohibited_licenses", [
            "GPL-3.0", "AGPL-3.0", "SSPL-1.0", "BCL"
        ])
        
        for package, license_data in license_info.items():
            license_name = license_data.get("license", "unknown")
            
            if license_name in prohibited_licenses:
                issues.append(self.create_issue(
                    issue_type="license_compliance_violation",
                    severity="medium",
                    message=f"Prohibited license detected: {package} uses {license_name}",
                    data={
                        "package_name": package,
                        "license": license_name,
                        "license_url": license_data.get("license_url", ""),
                        "recommendation": f"Replace package {package} or get legal approval for {license_name}"
                    }
                ))
        
        return issues
    
    def _should_scan(self, scan_key: str) -> bool:
        """Check if enough time has passed since last scan."""
        last_scan = self.last_scan_times.get(scan_key)
        if not last_scan:
            return True
        
        time_since_scan = datetime.utcnow() - last_scan
        return time_since_scan.total_seconds() > (self.min_scan_interval_hours * 3600)
    
    async def _get_dependency_files(self, context: Context) -> List[Dict[str, Any]]:
        """Get dependency files from the repository."""
        # Mock implementation - in production, would analyze actual files
        return [
            {
                "path": "requirements.txt",
                "type": "pip",
                "dependencies": [
                    {"name": "flask", "version": "2.0.1"},
                    {"name": "numpy", "version": "1.21.0"},
                    {"name": "tensorflow", "version": "2.5.0"},
                    {"name": "requests", "version": "2.25.1"},
                    {"name": "pillow", "version": "8.2.0"}  # Has known vulnerabilities
                ]
            },
            {
                "path": "package.json",
                "type": "npm",
                "dependencies": [
                    {"name": "lodash", "version": "4.17.20"},  # Has known vulnerabilities
                    {"name": "express", "version": "4.17.1"},
                    {"name": "react", "version": "17.0.2"}
                ]
            }
        ]
    
    async def _check_dependencies_for_vulnerabilities(
        self, dependencies: List[Dict[str, Any]], file_type: str, file_path: str
    ) -> List[Dict[str, Any]]:
        """Check dependencies against vulnerability databases."""
        vulnerabilities = []
        
        # Mock vulnerability database lookup
        known_vulnerabilities = {
            "pillow:8.2.0": {
                "id": "GHSA-8vj2-vxx3-667w",
                "package": "pillow",
                "version": "8.2.0",
                "title": "Pillow buffer overflow in Convert.c",
                "description": "Buffer overflow in Convert.c in Pillow before 8.3.2",
                "cve_ids": ["CVE-2021-34552"],
                "cvss_score": 9.8,
                "severity": "critical",
                "published": "2021-07-13T00:00:00Z",
                "fixed_versions": ["8.3.2", "9.0.0"]
            },
            "lodash:4.17.20": {
                "id": "GHSA-p6mc-m468-83gw",
                "package": "lodash",
                "version": "4.17.20",
                "title": "Prototype Pollution in lodash",
                "description": "lodash versions prior to 4.17.21 are vulnerable to Command Injection",
                "cve_ids": ["CVE-2021-23337"],
                "cvss_score": 7.2,
                "severity": "high",
                "published": "2021-02-15T00:00:00Z",
                "fixed_versions": ["4.17.21"]
            }
        }
        
        for dep in dependencies:
            dep_key = f"{dep['name']}:{dep['version']}"
            if dep_key in known_vulnerabilities:
                vulnerabilities.append(known_vulnerabilities[dep_key])
        
        return vulnerabilities
    
    def _initialize_secret_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Initialize patterns for detecting secrets."""
        return {
            "aws_access_key": {
                "pattern": r"AKIA[0-9A-Z]{16}",
                "description": "AWS Access Key ID",
                "confidence": "high"
            },
            "aws_secret_key": {
                "pattern": r"[0-9a-zA-Z/+]{40}",
                "description": "AWS Secret Access Key",
                "confidence": "medium"
            },
            "github_token": {
                "pattern": r"ghp_[0-9a-zA-Z]{36}",
                "description": "GitHub Personal Access Token",
                "confidence": "high"
            },
            "api_key_generic": {
                "pattern": r"['\"]?[Aa][Pp][Ii][_-]?[Kk][Ee][Yy]['\"]?\s*[:=]\s*['\"]?[0-9a-zA-Z-_]{16,}['\"]?",
                "description": "Generic API Key",
                "confidence": "medium"
            },
            "private_key": {
                "pattern": r"-----BEGIN [A-Z]+ PRIVATE KEY-----",
                "description": "Private Key",
                "confidence": "high"
            },
            "password_in_url": {
                "pattern": r"[a-zA-Z0-9+/.-]+://[^:]+:[^@]+@",
                "description": "Password in URL",
                "confidence": "high"
            },
            "jwt_token": {
                "pattern": r"eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*",
                "description": "JWT Token",
                "confidence": "medium"
            }
        }
    
    def _initialize_security_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Initialize patterns for detecting security issues in code."""
        return {
            "sql_injection": {
                "patterns": [
                    r"execute\s*\(\s*[\"'][^\"']*\+",
                    r"query\s*\(\s*[\"'][^\"']*\%",
                    r"\.format\s*\([^)]*\)\s*\)",
                ],
                "description": "Potential SQL injection vulnerability",
                "cwe_id": "CWE-89",
                "severity": "high"
            },
            "command_injection": {
                "patterns": [
                    r"os\.system\s*\([^)]*\+",
                    r"subprocess\.[a-z]+\s*\([^)]*\+",
                    r"exec\s*\([^)]*\+",
                ],
                "description": "Potential command injection vulnerability",
                "cwe_id": "CWE-78",
                "severity": "high"
            },
            "path_traversal": {
                "patterns": [
                    r"open\s*\([^)]*\+[^)]*[\"'][^\"']*\.\.",
                    r"file\s*\([^)]*\+[^)]*[\"'][^\"']*\.\.",
                ],
                "description": "Potential path traversal vulnerability",
                "cwe_id": "CWE-22",
                "severity": "medium"
            },
            "weak_crypto": {
                "patterns": [
                    r"hashlib\.md5\(",
                    r"hashlib\.sha1\(",
                    r"Crypto\.Hash\.MD5",
                    r"Crypto\.Hash\.SHA1",
                ],
                "description": "Use of weak cryptographic algorithm",
                "cwe_id": "CWE-327",
                "severity": "medium"
            },
            "hardcoded_secret": {
                "patterns": [
                    r"password\s*=\s*[\"'][^\"']{8,}[\"']",
                    r"secret\s*=\s*[\"'][^\"']{8,}[\"']",
                    r"token\s*=\s*[\"'][^\"']{16,}[\"']",
                ],
                "description": "Hardcoded secret or credential",
                "cwe_id": "CWE-798",
                "severity": "high"
            }
        }
    
    def _scan_file_for_secrets(self, file_path: str, content: str) -> List[Dict[str, Any]]:
        """Scan file content for potential secrets."""
        secrets = []
        
        lines = content.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            for pattern_name, pattern_info in self.secret_patterns.items():
                pattern = pattern_info["pattern"]
                
                matches = re.finditer(pattern, line, re.IGNORECASE)
                for match in matches:
                    # Calculate entropy for better confidence
                    matched_text = match.group()
                    entropy = self._calculate_entropy(matched_text)
                    
                    # Skip if it looks like a placeholder or example
                    if self._is_placeholder(matched_text):
                        continue
                    
                    secrets.append({
                        "type": pattern_name,
                        "description": pattern_info["description"],
                        "pattern_name": pattern_name,
                        "line_number": line_num,
                        "entropy": entropy,
                        "confidence": self._adjust_confidence(pattern_info["confidence"], entropy)
                    })
        
        return secrets
    
    def _scan_file_for_security_issues(self, file_path: str, content: str) -> List[Dict[str, Any]]:
        """Scan file for security anti-patterns and vulnerabilities."""
        issues = []
        
        lines = content.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            for pattern_type, pattern_info in self.security_patterns.items():
                for pattern in pattern_info["patterns"]:
                    if re.search(pattern, line, re.IGNORECASE):
                        issues.append({
                            "pattern_type": pattern_type,
                            "title": f"{pattern_type.replace('_', ' ').title()} detected",
                            "description": pattern_info["description"],
                            "severity": pattern_info["severity"],
                            "cwe_id": pattern_info.get("cwe_id", ""),
                            "line_number": line_num,
                            "code_snippet": line.strip(),
                            "recommendation": self._get_security_pattern_recommendation(pattern_type)
                        })
        
        return issues
    
    async def _get_source_files(self, context: Context) -> List[Dict[str, Any]]:
        """Get source code files for scanning."""
        # Mock implementation
        return [
            {
                "path": "src/app.py",
                "content": """
import os
import hashlib
import subprocess

# Potential security issues
password = "hardcoded_password123"
db_query = "SELECT * FROM users WHERE id = " + user_id
os.system("ls " + user_input)
hash = hashlib.md5(data.encode()).hexdigest()
"""
            },
            {
                "path": "config/settings.py", 
                "content": """
DATABASE_URL = "postgresql://user:secret123@localhost/db"
API_KEY = "sk-1234567890abcdef"
JWT_SECRET = "super_secret_key_dont_share"
"""
            }
        ]
    
    async def _get_container_files(self, context: Context) -> List[Dict[str, Any]]:
        """Get container definition files."""
        # Mock implementation
        return [
            {
                "path": "Dockerfile",
                "base_images": ["ubuntu:18.04", "python:3.8-slim"]
            },
            {
                "path": "docker-compose.yml",
                "base_images": ["redis:6.0", "postgres:12"]
            }
        ]
    
    async def _scan_container_image(self, image: str, file_path: str) -> List[Dict[str, Any]]:
        """Scan container image for vulnerabilities."""
        # Mock vulnerability data
        if "ubuntu:18.04" in image:
            return [
                {
                    "id": "CVE-2021-3711",
                    "title": "OpenSSL buffer overflow vulnerability",
                    "package": "libssl1.1",
                    "version": "1.1.1-1ubuntu2.1~18.04.13",
                    "cvss_score": 9.8,
                    "description": "Buffer overflow in OpenSSL",
                    "layer": "base"
                }
            ]
        elif "python:3.8-slim" in image:
            return [
                {
                    "id": "CVE-2021-28861",
                    "title": "Python tarfile directory traversal",
                    "package": "python3.8",
                    "version": "3.8.10",
                    "cvss_score": 7.5,
                    "description": "Directory traversal in tarfile module",
                    "layer": "application"
                }
            ]
        
        return []
    
    async def _get_configuration_files(self, context: Context) -> List[Dict[str, Any]]:
        """Get configuration files for security analysis."""
        # Mock implementation
        return [
            {
                "path": ".github/workflows/ci.yml",
                "type": "github_workflow",
                "content": {
                    "name": "CI",
                    "on": ["push", "pull_request"],
                    "jobs": {
                        "test": {
                            "runs-on": "ubuntu-latest",
                            "steps": [
                                {
                                    "name": "Checkout",
                                    "uses": "actions/checkout@v2"  # Outdated action
                                }
                            ]
                        }
                    }
                }
            },
            {
                "path": "docker-compose.yml",
                "type": "docker_compose",
                "content": {
                    "version": "3",
                    "services": {
                        "web": {
                            "image": "nginx",
                            "ports": ["80:80"],
                            "privileged": True  # Security issue
                        }
                    }
                }
            }
        ]
    
    def _analyze_config_security(self, file_path: str, file_type: str, config_content: Any) -> List[Dict[str, Any]]:
        """Analyze configuration for security issues."""
        issues = []
        
        if file_type == "github_workflow":
            issues.extend(self._analyze_github_workflow_security(config_content))
        elif file_type == "docker_compose":
            issues.extend(self._analyze_docker_compose_security(config_content))
        
        return issues
    
    def _analyze_github_workflow_security(self, workflow: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze GitHub workflow for security issues."""
        issues = []
        
        jobs = workflow.get("jobs", {})
        for job_name, job_config in jobs.items():
            steps = job_config.get("steps", [])
            
            for step in steps:
                uses = step.get("uses", "")
                
                # Check for outdated actions
                if "actions/checkout@v2" in uses:
                    issues.append({
                        "issue_type": "outdated_action",
                        "title": "Outdated GitHub Action",
                        "description": "Using outdated version of actions/checkout",
                        "severity": "medium",
                        "current_value": "v2",
                        "recommended_value": "v4",
                        "recommendation": "Update to actions/checkout@v4 for security fixes"
                    })
                
                # Check for shell injection risks
                run_command = step.get("run", "")
                if "${{" in run_command and "github." in run_command:
                    issues.append({
                        "issue_type": "shell_injection_risk",
                        "title": "Potential Shell Injection",
                        "description": "Using GitHub context in shell command without proper escaping",
                        "severity": "high",
                        "recommendation": "Use environment variables or proper escaping"
                    })
        
        return issues
    
    def _analyze_docker_compose_security(self, compose: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze Docker Compose file for security issues."""
        issues = []
        
        services = compose.get("services", {})
        for service_name, service_config in services.items():
            # Check for privileged containers
            if service_config.get("privileged"):
                issues.append({
                    "issue_type": "privileged_container",
                    "title": "Privileged Container",
                    "description": f"Service '{service_name}' runs in privileged mode",
                    "severity": "high",
                    "current_value": "true",
                    "recommended_value": "false",
                    "recommendation": "Remove privileged mode unless absolutely necessary"
                })
            
            # Check for exposed ports
            ports = service_config.get("ports", [])
            for port_mapping in ports:
                if isinstance(port_mapping, str) and ":80" in port_mapping:
                    issues.append({
                        "issue_type": "insecure_port_binding",
                        "title": "Insecure Port Binding",
                        "description": f"Service '{service_name}' exposes port 80 (HTTP)",
                        "severity": "medium",
                        "recommendation": "Use HTTPS (port 443) instead of HTTP"
                    })
        
        return issues
    
    async def _get_text_files(self, context: Context) -> List[Dict[str, Any]]:
        """Get text files for secret scanning."""
        # Mock implementation - would scan actual repository files
        return [
            {
                "path": "config.py",
                "content": """
AWS_ACCESS_KEY = "AKIAIOSFODNN7EXAMPLE"
DATABASE_PASSWORD = "super_secret_password_123"
API_TOKEN = "ghp_1234567890abcdef1234567890abcdef123"
"""
            }
        ]
    
    async def _assess_cicd_security(self, context: Context) -> List[Dict[str, Any]]:
        """Assess CI/CD pipeline security."""
        issues = []
        
        # Mock CI/CD security assessment
        cicd_issues = [
            {
                "type": "missing_security_scan",
                "title": "Missing Security Scan",
                "description": "No security scanning step in CI/CD pipeline",
                "severity": "medium",
                "recommendation": "Add dependency and container security scanning"
            },
            {
                "type": "insufficient_branch_protection",
                "title": "Insufficient Branch Protection",
                "description": "Main branch allows force pushes",
                "severity": "high", 
                "recommendation": "Enable branch protection rules with required reviews"
            }
        ]
        
        for issue in cicd_issues:
            issues.append(self.create_issue(
                issue_type="cicd_security_issue",
                severity=issue["severity"],
                message=issue["title"],
                data={
                    "issue_type": issue["type"],
                    "description": issue["description"],
                    "recommendation": issue["recommendation"]
                }
            ))
        
        return issues
    
    async def _assess_repository_security(self, context: Context) -> List[Dict[str, Any]]:
        """Assess repository security settings."""
        issues = []
        
        # Mock repository security assessment
        repo_issues = [
            {
                "type": "no_signed_commits",
                "title": "Unsigned Commits",
                "description": "Repository allows unsigned commits",
                "severity": "medium",
                "recommendation": "Require signed commits for better integrity"
            }
        ]
        
        for issue in repo_issues:
            issues.append(self.create_issue(
                issue_type="repository_security_issue",
                severity=issue["severity"],
                message=issue["title"],
                data={
                    "issue_type": issue["type"],
                    "description": issue["description"],
                    "recommendation": issue["recommendation"]
                }
            ))
        
        return issues
    
    async def _get_dependency_licenses(self, context: Context) -> Dict[str, Dict[str, Any]]:
        """Get license information for dependencies."""
        # Mock license data
        return {
            "flask": {"license": "BSD-3-Clause", "license_url": "https://opensource.org/licenses/BSD-3-Clause"},
            "numpy": {"license": "BSD-3-Clause", "license_url": "https://opensource.org/licenses/BSD-3-Clause"},
            "tensorflow": {"license": "Apache-2.0", "license_url": "https://opensource.org/licenses/Apache-2.0"},
            "problematic_package": {"license": "GPL-3.0", "license_url": "https://opensource.org/licenses/GPL-3.0"}
        }
    
    def _calculate_vulnerability_severity(self, vulnerability: Dict[str, Any]) -> str:
        """Calculate severity based on CVSS score and other factors."""
        cvss_score = vulnerability.get("cvss_score", 0)
        
        if cvss_score >= self.critical_score_threshold:
            return "critical"
        elif cvss_score >= self.high_score_threshold:
            return "high"
        elif cvss_score >= self.medium_score_threshold:
            return "medium"
        else:
            return "low"
    
    def _calculate_container_vulnerability_severity(self, vulnerability: Dict[str, Any]) -> str:
        """Calculate severity for container vulnerabilities."""
        # Similar to dependency vulnerabilities but may consider layer context
        return self._calculate_vulnerability_severity(vulnerability)
    
    def _get_secret_severity(self, secret_type: str) -> str:
        """Get severity level for different types of secrets."""
        high_severity_secrets = ["aws_access_key", "github_token", "private_key", "password_in_url"]
        
        if secret_type in high_severity_secrets:
            return "high"
        else:
            return "medium"
    
    def _calculate_entropy(self, text: str) -> float:
        """Calculate entropy of text to help identify real secrets."""
        import math
        
        if len(text) == 0:
            return 0
        
        char_counts = {}
        for char in text:
            char_counts[char] = char_counts.get(char, 0) + 1
        
        entropy = 0
        for count in char_counts.values():
            probability = count / len(text)
            entropy -= probability * math.log2(probability)
        
        return entropy
    
    def _is_placeholder(self, text: str) -> bool:
        """Check if text looks like a placeholder or example."""
        placeholder_patterns = [
            r"xxx+", r"example", r"placeholder", r"your_.*_here",
            r"replace_.*", r"<.*>", r"\[.*\]", r"test.*", r"dummy.*"
        ]
        
        text_lower = text.lower()
        for pattern in placeholder_patterns:
            if re.search(pattern, text_lower):
                return True
        
        return False
    
    def _adjust_confidence(self, base_confidence: str, entropy: float) -> str:
        """Adjust confidence based on entropy score."""
        if entropy < 2.0:
            return "low"
        elif entropy > 4.0 and base_confidence == "medium":
            return "high"
        else:
            return base_confidence
    
    def _get_vulnerability_recommendation(self, vulnerability: Dict[str, Any]) -> str:
        """Get specific recommendation for vulnerability remediation."""
        fixed_versions = vulnerability.get("fixed_versions", [])
        package = vulnerability.get("package", "")
        
        if fixed_versions:
            latest_fix = fixed_versions[-1]
            return f"Update {package} to version {latest_fix} or later"
        else:
            return f"Review vulnerability details and consider alternative packages for {package}"
    
    def _get_container_vulnerability_recommendation(self, vulnerability: Dict[str, Any]) -> str:
        """Get recommendation for container vulnerability remediation."""
        return f"Update base image or apply security patches for {vulnerability.get('package', 'affected package')}"
    
    def _get_security_pattern_recommendation(self, pattern_type: str) -> str:
        """Get recommendation for security pattern issues."""
        recommendations = {
            "sql_injection": "Use parameterized queries or prepared statements",
            "command_injection": "Use subprocess with argument lists instead of shell=True",
            "path_traversal": "Validate and sanitize file paths, use safe path joining",
            "weak_crypto": "Use stronger hashing algorithms like SHA-256 or bcrypt",
            "hardcoded_secret": "Use environment variables or secure secret management"
        }
        
        return recommendations.get(pattern_type, "Review code for security best practices")