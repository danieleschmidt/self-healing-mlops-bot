"""API security with JWT tokens and comprehensive protection."""

import asyncio
import hashlib
import hmac
import json
import time
import uuid
from typing import Dict, List, Optional, Any, Set, Tuple, Union
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
import logging

import jwt
from fastapi import HTTPException, Request, Response, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.base import BaseHTTPMiddleware

from ..core.config import config
from ..monitoring.logging import get_logger, audit_logger
from .auth import User, auth_manager, authz_manager
from .validation import SecurityValidator, ValidationError
from .rate_limiting import rate_limiter
from .monitoring import security_monitor, SecurityEventType, ThreatLevel

logger = get_logger(__name__)


class TokenType(Enum):
    """JWT token types."""
    ACCESS = "access"
    REFRESH = "refresh"
    API = "api"
    WEBHOOK = "webhook"


class SecurityLevel(Enum):
    """Security levels for API endpoints."""
    PUBLIC = "public"
    AUTHENTICATED = "authenticated"
    PRIVILEGED = "privileged"
    ADMIN_ONLY = "admin_only"


@dataclass
class APISecurityConfig:
    """API security configuration."""
    jwt_secret: str
    access_token_expire_minutes: int = 60
    refresh_token_expire_days: int = 30
    max_failed_attempts: int = 5
    lockout_duration_minutes: int = 30
    require_https: bool = True
    cors_origins: List[str] = field(default_factory=list)
    rate_limiting_enabled: bool = True
    request_validation_enabled: bool = True
    audit_logging_enabled: bool = True


class JWTManager:
    """JWT token management with security features."""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.algorithm = "HS256"
        self.blacklisted_tokens: Set[str] = set()
        self.token_families: Dict[str, Set[str]] = {}  # user_id -> token_jti_set
    
    def create_access_token(self, user: User, expires_delta: Optional[timedelta] = None) -> str:
        """Create JWT access token."""
        if expires_delta is None:
            expires_delta = timedelta(minutes=60)
        
        now = datetime.utcnow()
        expire = now + expires_delta
        jti = str(uuid.uuid4())
        
        payload = {
            "sub": user.user_id,
            "username": user.username,
            "role": user.role.value,
            "permissions": [p.value for p in user.permissions],
            "type": TokenType.ACCESS.value,
            "iat": now,
            "exp": expire,
            "jti": jti,
            "iss": "self-healing-bot",
            "aud": "api"
        }
        
        token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
        
        # Track token family for user
        if user.user_id not in self.token_families:
            self.token_families[user.user_id] = set()
        self.token_families[user.user_id].add(jti)
        
        return token
    
    def create_refresh_token(self, user: User, expires_delta: Optional[timedelta] = None) -> str:
        """Create JWT refresh token."""
        if expires_delta is None:
            expires_delta = timedelta(days=30)
        
        now = datetime.utcnow()
        expire = now + expires_delta
        jti = str(uuid.uuid4())
        
        payload = {
            "sub": user.user_id,
            "type": TokenType.REFRESH.value,
            "iat": now,
            "exp": expire,
            "jti": jti,
            "iss": "self-healing-bot",
            "aud": "api"
        }
        
        token = jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
        
        # Track token family
        if user.user_id not in self.token_families:
            self.token_families[user.user_id] = set()
        self.token_families[user.user_id].add(jti)
        
        return token
    
    def create_api_token(self, user: User, expires_delta: Optional[timedelta] = None) -> str:
        """Create long-lived API token."""
        if expires_delta is None:
            expires_delta = timedelta(days=365)  # 1 year default
        
        now = datetime.utcnow()
        expire = now + expires_delta
        jti = str(uuid.uuid4())
        
        payload = {
            "sub": user.user_id,
            "username": user.username,
            "role": user.role.value,
            "permissions": [p.value for p in user.permissions],
            "type": TokenType.API.value,
            "iat": now,
            "exp": expire,
            "jti": jti,
            "iss": "self-healing-bot",
            "aud": "api"
        }
        
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str, token_type: Optional[TokenType] = None) -> Dict[str, Any]:
        """Verify and decode JWT token."""
        try:
            # Check if token is blacklisted
            token_hash = hashlib.sha256(token.encode()).hexdigest()[:16]
            if token_hash in self.blacklisted_tokens:
                raise jwt.InvalidTokenError("Token is blacklisted")
            
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            
            # Verify token type if specified
            if token_type and payload.get("type") != token_type.value:
                raise jwt.InvalidTokenError(f"Invalid token type: expected {token_type.value}")
            
            # Verify issuer and audience
            if payload.get("iss") != "self-healing-bot" or payload.get("aud") != "api":
                raise jwt.InvalidTokenError("Invalid token issuer or audience")
            
            # Check if token family is still valid
            user_id = payload.get("sub")
            jti = payload.get("jti")
            
            if user_id and jti:
                user_tokens = self.token_families.get(user_id, set())
                if jti not in user_tokens:
                    raise jwt.InvalidTokenError("Token family invalidated")
            
            return payload
            
        except jwt.ExpiredSignatureError:
            raise jwt.InvalidTokenError("Token has expired")
        except jwt.InvalidTokenError as e:
            raise e
        except Exception as e:
            raise jwt.InvalidTokenError(f"Token validation failed: {e}")
    
    def blacklist_token(self, token: str):
        """Add token to blacklist."""
        token_hash = hashlib.sha256(token.encode()).hexdigest()[:16]
        self.blacklisted_tokens.add(token_hash)
    
    def revoke_user_tokens(self, user_id: str):
        """Revoke all tokens for a user."""
        if user_id in self.token_families:
            del self.token_families[user_id]
        
        audit_logger.log_security_event(
            "user_tokens_revoked", "info",
            {"user_id": user_id}
        )
    
    def cleanup_expired_tokens(self):
        """Clean up expired tokens from blacklist and families."""
        # This would be more sophisticated in production
        # For now, we'll just clean up very old entries
        if len(self.blacklisted_tokens) > 10000:
            # Keep only the most recent 5000 blacklisted tokens
            self.blacklisted_tokens = set(list(self.blacklisted_tokens)[-5000:])


class APISecurityMiddleware(BaseHTTPMiddleware):\n    \"\"\"Comprehensive API security middleware.\"\"\"\n    \n    def __init__(self, app, config: APISecurityConfig):\n        super().__init__(app)\n        self.config = config\n        self.jwt_manager = JWTManager(config.jwt_secret)\n        self.security_validator = SecurityValidator()\n        self.bearer_scheme = HTTPBearer(auto_error=False)\n        \n        # Endpoint security configuration\n        self.endpoint_security = {\n            \"/health\": SecurityLevel.PUBLIC,\n            \"/metrics\": SecurityLevel.AUTHENTICATED,\n            \"/webhooks\": SecurityLevel.AUTHENTICATED,\n            \"/api/v1/trigger\": SecurityLevel.PRIVILEGED,\n            \"/api/v1/users\": SecurityLevel.ADMIN_ONLY,\n            \"/api/v1/secrets\": SecurityLevel.ADMIN_ONLY,\n            \"/api/v1/system\": SecurityLevel.ADMIN_ONLY\n        }\n    \n    async def dispatch(self, request: Request, call_next):\n        \"\"\"Process request through security middleware.\"\"\"\n        start_time = time.time()\n        client_ip = self._get_client_ip(request)\n        \n        try:\n            # 1. HTTPS enforcement\n            if self.config.require_https and request.url.scheme != \"https\":\n                return self._create_error_response(\n                    \"HTTPS required\", 400, \"https_required\"\n                )\n            \n            # 2. Request validation\n            if self.config.request_validation_enabled:\n                try:\n                    await self.security_validator.validate_request(request)\n                except ValidationError as e:\n                    await security_monitor.log_security_event(\n                        SecurityEventType.SUSPICIOUS_ACTIVITY,\n                        ThreatLevel.MEDIUM,\n                        source_ip=client_ip,\n                        endpoint=str(request.url.path),\n                        details={\"validation_error\": str(e), \"error_type\": e.error_type}\n                    )\n                    return self._create_error_response(\n                        \"Request validation failed\", 400, \"validation_failed\"\n                    )\n                except Exception as e:\n                    logger.error(f\"Request validation error: {e}\")\n                    return self._create_error_response(\n                        \"Request validation error\", 400, \"validation_error\"\n                    )\n            \n            # 3. Rate limiting\n            if self.config.rate_limiting_enabled:\n                user_id = await self._extract_user_id_for_rate_limiting(request)\n                is_allowed, violation = await rate_limiter.check_rate_limit(\n                    client_ip=client_ip,\n                    endpoint=request.url.path,\n                    user_id=user_id,\n                    request_size=int(request.headers.get(\"content-length\", 0))\n                )\n                \n                if not is_allowed:\n                    response = self._create_error_response(\n                        \"Rate limit exceeded\", 429, \"rate_limit_exceeded\"\n                    )\n                    if violation and violation.blocked_until:\n                        response.headers[\"Retry-After\"] = str(\n                            int((violation.blocked_until - datetime.utcnow()).total_seconds())\n                        )\n                    return response\n            \n            # 4. Authentication and authorization\n            auth_result = await self._authenticate_request(request)\n            if isinstance(auth_result, Response):  # Error response\n                return auth_result\n            \n            user, token_payload = auth_result\n            \n            # 5. Endpoint-specific authorization\n            if not self._authorize_endpoint_access(request, user):\n                await security_monitor.log_security_event(\n                    SecurityEventType.AUTHORIZATION_FAILURE,\n                    ThreatLevel.MEDIUM,\n                    source_ip=client_ip,\n                    endpoint=request.url.path,\n                    user_id=user.user_id if user else None\n                )\n                return self._create_error_response(\n                    \"Access denied\", 403, \"access_denied\"\n                )\n            \n            # 6. Add security context to request\n            request.state.user = user\n            request.state.token_payload = token_payload\n            request.state.client_ip = client_ip\n            \n            # 7. Process request\n            await rate_limiter.increment_concurrent_connections(client_ip)\n            \n            try:\n                response = await call_next(request)\n            finally:\n                await rate_limiter.decrement_concurrent_connections(client_ip)\n            \n            # 8. Add security headers\n            self._add_security_headers(response)\n            \n            # 9. Audit logging\n            if self.config.audit_logging_enabled:\n                await self._log_request(\n                    request, response, user, time.time() - start_time\n                )\n            \n            return response\n            \n        except Exception as e:\n            logger.error(f\"Security middleware error: {e}\")\n            await security_monitor.log_security_event(\n                SecurityEventType.SUSPICIOUS_ACTIVITY,\n                ThreatLevel.HIGH,\n                source_ip=client_ip,\n                details={\"middleware_error\": str(e)}\n            )\n            return self._create_error_response(\n                \"Internal security error\", 500, \"security_error\"\n            )\n    \n    def _get_client_ip(self, request: Request) -> str:\n        \"\"\"Extract client IP address from request.\"\"\"\n        # Check forwarded headers (in order of preference)\n        forwarded_headers = [\n            \"x-forwarded-for\",\n            \"x-real-ip\",\n            \"cf-connecting-ip\",  # Cloudflare\n            \"x-client-ip\"\n        ]\n        \n        for header in forwarded_headers:\n            if header in request.headers:\n                # Get first IP from comma-separated list\n                ip = request.headers[header].split(\",\")[0].strip()\n                if ip:\n                    return ip\n        \n        # Fall back to direct connection IP\n        return request.client.host if request.client else \"unknown\"\n    \n    async def _extract_user_id_for_rate_limiting(self, request: Request) -> Optional[str]:\n        \"\"\"Extract user ID for rate limiting without full authentication.\"\"\"\n        try:\n            # Try to extract from Authorization header\n            auth_header = request.headers.get(\"Authorization\")\n            if auth_header and auth_header.startswith(\"Bearer \"):\n                token = auth_header.split(\" \")[1]\n                payload = self.jwt_manager.verify_token(token)\n                return payload.get(\"sub\")\n        except Exception:\n            pass\n        \n        return None\n    \n    async def _authenticate_request(self, request: Request) -> Union[Tuple[Optional[User], Optional[Dict]], Response]:\n        \"\"\"Authenticate the request and return user or error response.\"\"\"\n        endpoint_security = self._get_endpoint_security_level(request.url.path)\n        \n        # Public endpoints don't require authentication\n        if endpoint_security == SecurityLevel.PUBLIC:\n            return None, None\n        \n        # Try different authentication methods\n        user, token_payload = None, None\n        \n        # 1. Bearer token (JWT)\n        auth_header = request.headers.get(\"Authorization\")\n        if auth_header and auth_header.startswith(\"Bearer \"):\n            token = auth_header.split(\" \")[1]\n            try:\n                token_payload = self.jwt_manager.verify_token(token)\n                user_id = token_payload.get(\"sub\")\n                user = auth_manager.get_user_by_id(user_id)\n                \n                if not user or not user.is_active:\n                    raise jwt.InvalidTokenError(\"User not found or inactive\")\n                \n            except jwt.InvalidTokenError as e:\n                await security_monitor.log_security_event(\n                    SecurityEventType.AUTHENTICATION_FAILURE,\n                    ThreatLevel.MEDIUM,\n                    source_ip=self._get_client_ip(request),\n                    details={\"method\": \"jwt\", \"error\": str(e)}\n                )\n                return self._create_error_response(\n                    \"Invalid token\", 401, \"invalid_token\"\n                )\n        \n        # 2. API Key\n        elif \"X-API-Key\" in request.headers:\n            api_key = request.headers[\"X-API-Key\"]\n            try:\n                user = await auth_manager.authenticate_api_key(api_key)\n            except Exception as e:\n                await security_monitor.log_security_event(\n                    SecurityEventType.AUTHENTICATION_FAILURE,\n                    ThreatLevel.MEDIUM,\n                    source_ip=self._get_client_ip(request),\n                    details={\"method\": \"api_key\", \"error\": str(e)}\n                )\n                return self._create_error_response(\n                    \"Invalid API key\", 401, \"invalid_api_key\"\n                )\n        \n        # Authentication required but not provided\n        if not user and endpoint_security != SecurityLevel.PUBLIC:\n            return self._create_error_response(\n                \"Authentication required\", 401, \"authentication_required\"\n            )\n        \n        return user, token_payload\n    \n    def _get_endpoint_security_level(self, path: str) -> SecurityLevel:\n        \"\"\"Get security level for an endpoint.\"\"\"\n        # Check exact matches first\n        if path in self.endpoint_security:\n            return self.endpoint_security[path]\n        \n        # Check pattern matches\n        for pattern, security_level in self.endpoint_security.items():\n            if pattern.endswith(\"*\") and path.startswith(pattern[:-1]):\n                return security_level\n        \n        # Default to authenticated\n        return SecurityLevel.AUTHENTICATED\n    \n    def _authorize_endpoint_access(self, request: Request, user: Optional[User]) -> bool:\n        \"\"\"Check if user is authorized to access the endpoint.\"\"\"\n        security_level = self._get_endpoint_security_level(request.url.path)\n        \n        if security_level == SecurityLevel.PUBLIC:\n            return True\n        \n        if not user:\n            return False\n        \n        if security_level == SecurityLevel.AUTHENTICATED:\n            return True\n        \n        if security_level == SecurityLevel.PRIVILEGED:\n            return authz_manager.check_resource_access(user, request.url.path, request.method)\n        \n        if security_level == SecurityLevel.ADMIN_ONLY:\n            from .auth import UserRole\n            return user.role == UserRole.ADMIN\n        \n        return False\n    \n    def _add_security_headers(self, response: Response):\n        \"\"\"Add security headers to response.\"\"\"\n        security_headers = {\n            \"X-Content-Type-Options\": \"nosniff\",\n            \"X-Frame-Options\": \"DENY\",\n            \"X-XSS-Protection\": \"1; mode=block\",\n            \"Strict-Transport-Security\": \"max-age=31536000; includeSubDomains\",\n            \"Content-Security-Policy\": \"default-src 'self'\",\n            \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n            \"Permissions-Policy\": \"geolocation=(), microphone=(), camera=()\"\n        }\n        \n        for header, value in security_headers.items():\n            response.headers[header] = value\n    \n    def _create_error_response(self, message: str, status_code: int, error_code: str) -> Response:\n        \"\"\"Create standardized error response.\"\"\"\n        error_response = {\n            \"error\": {\n                \"message\": message,\n                \"code\": error_code,\n                \"timestamp\": datetime.utcnow().isoformat()\n            }\n        }\n        \n        response = Response(\n            content=json.dumps(error_response),\n            status_code=status_code,\n            media_type=\"application/json\"\n        )\n        \n        self._add_security_headers(response)\n        return response\n    \n    async def _log_request(self, request: Request, response: Response, \n                          user: Optional[User], duration: float):\n        \"\"\"Log request for audit purposes.\"\"\"\n        log_data = {\n            \"method\": request.method,\n            \"path\": request.url.path,\n            \"query_params\": dict(request.query_params),\n            \"status_code\": response.status_code,\n            \"duration_ms\": round(duration * 1000, 2),\n            \"client_ip\": self._get_client_ip(request),\n            \"user_agent\": request.headers.get(\"user-agent\"),\n            \"user_id\": user.user_id if user else None,\n            \"username\": user.username if user else None,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        \n        # Determine log level based on status code\n        if response.status_code >= 500:\n            log_level = \"error\"\n            severity = \"high\"\n        elif response.status_code >= 400:\n            log_level = \"warning\"\n            severity = \"medium\"\n        else:\n            log_level = \"info\"\n            severity = \"low\"\n        \n        audit_logger.log_security_event(\n            \"api_request\", severity, log_data\n        )\n\n\nclass WebhookSecurityValidator:\n    \"\"\"Webhook signature validation and security.\"\"\"\n    \n    def __init__(self, secret_key: str):\n        self.secret_key = secret_key\n    \n    def validate_github_webhook(self, payload: bytes, signature: str) -> bool:\n        \"\"\"Validate GitHub webhook signature.\"\"\"\n        if not signature.startswith(\"sha256=\"):\n            return False\n        \n        expected_signature = hmac.new(\n            self.secret_key.encode(),\n            payload,\n            hashlib.sha256\n        ).hexdigest()\n        \n        received_signature = signature[7:]  # Remove 'sha256=' prefix\n        \n        return hmac.compare_digest(expected_signature, received_signature)\n    \n    def validate_generic_webhook(self, payload: bytes, signature: str, \n                                timestamp: str, tolerance_seconds: int = 300) -> bool:\n        \"\"\"Validate generic webhook with timestamp tolerance.\"\"\"\n        try:\n            # Check timestamp to prevent replay attacks\n            webhook_time = int(timestamp)\n            current_time = int(time.time())\n            \n            if abs(current_time - webhook_time) > tolerance_seconds:\n                return False\n            \n            # Validate signature\n            message = f\"{timestamp}.{payload.decode()}\"\n            expected_signature = hmac.new(\n                self.secret_key.encode(),\n                message.encode(),\n                hashlib.sha256\n            ).hexdigest()\n            \n            return hmac.compare_digest(expected_signature, signature)\n            \n        except (ValueError, TypeError):\n            return False\n\n\n# Security decorators for FastAPI\ndef require_auth(security_level: SecurityLevel = SecurityLevel.AUTHENTICATED):\n    \"\"\"Decorator to require authentication for FastAPI endpoints.\"\"\"\n    def decorator(func):\n        async def wrapper(request: Request, *args, **kwargs):\n            user = getattr(request.state, 'user', None)\n            \n            if security_level == SecurityLevel.PUBLIC:\n                return await func(request, *args, **kwargs)\n            \n            if not user:\n                raise HTTPException(status_code=401, detail=\"Authentication required\")\n            \n            if security_level == SecurityLevel.ADMIN_ONLY:\n                from .auth import UserRole\n                if user.role != UserRole.ADMIN:\n                    raise HTTPException(status_code=403, detail=\"Admin access required\")\n            \n            return await func(request, user=user, *args, **kwargs)\n        return wrapper\n    return decorator\n\n\ndef require_permission(permission: str):\n    \"\"\"Decorator to require specific permission.\"\"\"\n    def decorator(func):\n        async def wrapper(request: Request, *args, **kwargs):\n            user = getattr(request.state, 'user', None)\n            \n            if not user:\n                raise HTTPException(status_code=401, detail=\"Authentication required\")\n            \n            from .auth import Permission\n            required_perm = Permission(permission)\n            \n            if not authz_manager.check_permission(user, required_perm):\n                raise HTTPException(status_code=403, detail=f\"Permission required: {permission}\")\n            \n            return await func(request, user=user, *args, **kwargs)\n        return wrapper\n    return decorator\n\n\n# Create global instances\napi_security_config = APISecurityConfig(\n    jwt_secret=config.encryption_key,\n    cors_origins=[\"https://localhost\", \"https://127.0.0.1\"],\n    require_https=False,  # Set to True in production\n)\n\njwt_manager = JWTManager(api_security_config.jwt_secret)\nwebhook_validator = WebhookSecurityValidator(config.github_webhook_secret)\n\n# FastAPI security dependency\nsecurity_bearer = HTTPBearer()\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security_bearer)) -> User:\n    \"\"\"FastAPI dependency to get current authenticated user.\"\"\"\n    try:\n        payload = jwt_manager.verify_token(credentials.credentials)\n        user_id = payload.get(\"sub\")\n        user = auth_manager.get_user_by_id(user_id)\n        \n        if not user or not user.is_active:\n            raise HTTPException(status_code=401, detail=\"Invalid user\")\n        \n        return user\n        \n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")